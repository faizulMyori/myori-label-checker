import crypto from 'crypto';
import os from 'os';
import { fetchOne, executeQuery } from './db_helpers';

// Get secret key from environment variable
const SECRET_KEY = process.env.LICENSE_SECRET_KEY || 'default-key-for-development-only';

// Log a warning if using the default key in production
if (process.env.NODE_ENV === 'production' && SECRET_KEY === 'default-key-for-development-only') {
  console.warn('WARNING: Using default license secret key in production environment!');
}

// Get unique machine identifier based on hardware information
export function getMachineId(): string {
  try {
    // Collect hardware identifiers
    const cpus = os.cpus();
    const networkInterfaces = os.networkInterfaces();
    const hostname = os.hostname();
    
    // Create a string with hardware information
    let hardwareStr = hostname;
    
    // Add CPU information
    if (cpus && cpus.length > 0) {
      hardwareStr += cpus[0].model;
    }
    
    // Add MAC address (if available)
    const macs: string[] = [];
    Object.keys(networkInterfaces).forEach(interfaceName => {
      const interfaces = networkInterfaces[interfaceName];
      if (interfaces) {
        interfaces.forEach(iface => {
          if (!iface.internal && iface.mac && iface.mac !== '00:00:00:00:00:00') {
            macs.push(iface.mac);
          }
        });
      }
    });
    
    if (macs.length > 0) {
      // Sort to ensure consistent order
      macs.sort();
      hardwareStr += macs.join('');
    }
    
    // Create a hash of the hardware string
    const hash = crypto.createHash('sha256').update(hardwareStr).digest('hex');
    return hash;
  } catch (error) {
    console.error('Error generating machine ID:', error);
    // Fallback to a less reliable but still usable identifier
    return crypto.createHash('sha256').update(os.hostname()).digest('hex');
  }
}

// Note: generateLicenseKey function has been removed for security reasons
// License keys should be generated by a secure, separate tool or service

// Format license key in groups of 5 characters
function formatLicenseKey(key: string): string {
  const groups = [];
  for (let i = 0; i < key.length; i += 5) {
    groups.push(key.slice(i, i + 5));
  }
  return groups.join('-');
}

// Validate a license key against the current machine
export function validateLicenseKey(licenseKey: string): { valid: boolean; expiryDate?: Date; error?: string } {
  try {
    // Remove formatting
    const cleanKey = licenseKey.replace(/-/g, '');
    
    // Extract the checksum (last 8 characters)
    const checksum = cleanKey.slice(-8);
    const encryptedWithIV = cleanKey.slice(0, -8);
    
    // Verify checksum
    const calculatedChecksum = crypto.createHash('md5').update(encryptedWithIV).digest('hex').substring(0, 8);
    if (checksum !== calculatedChecksum) {
      return { valid: false, error: 'Invalid license key (checksum mismatch)' };
    }
    
    // Split the IV and encrypted data
    const [ivHex, encryptedLicense] = encryptedWithIV.split(':');
    if (!ivHex || !encryptedLicense) {
      return { valid: false, error: 'Invalid license key format' };
    }
    
    // Convert IV from hex to buffer
    const iv = Buffer.from(ivHex, 'hex');
    
    // Create key buffer from the secret key
    const key = crypto.scryptSync(SECRET_KEY, 'salt', 32);
    
    // Decrypt the license data using createDecipheriv
    const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
    let decrypted = decipher.update(encryptedLicense, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    // Parse the license data
    const licenseData = JSON.parse(decrypted);
    
    // Check if the license is for this machine
    const currentMachineId = getMachineId();
    if (licenseData.machineId !== currentMachineId) {
      return { valid: false, error: 'License key is not valid for this machine' };
    }
    
    // Check expiry date if present
    if (licenseData.expiryDate) {
      const expiryDate = new Date(licenseData.expiryDate);
      if (expiryDate < new Date()) {
        return { valid: false, expiryDate, error: 'License key has expired' };
      }
      return { valid: true, expiryDate };
    }
    
    return { valid: true };
  } catch (error) {
    console.error('Error validating license key:', error);
    return { valid: false, error: 'Invalid license key format' };
  }
}

// Initialize the license validation table
export function initializeLicenseValidationTable() {
  const sql = `
    CREATE TABLE IF NOT EXISTS license_validation (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      machine_id TEXT NOT NULL,
      license_key TEXT NOT NULL,
      is_valid INTEGER NOT NULL DEFAULT 0,
      expiry_date TEXT,
      last_checked TEXT NOT NULL,
      created_at INTEGER NOT NULL DEFAULT CURRENT_TIMESTAMP
    );
  `;
  executeQuery(sql);
}

// Save license validation result to database
export function saveLicenseValidation(licenseKey: string, isValid: boolean, expiryDate?: Date) {
  const machineId = getMachineId();
  const lastChecked = new Date().toISOString();
  
  // Check if a record already exists for this machine
  const existingRecord = fetchOne(
    "SELECT * FROM license_validation WHERE machine_id = ?", 
    [machineId]
  );
  
  if (existingRecord) {
    // Update existing record
    executeQuery(
      "UPDATE license_validation SET license_key = ?, is_valid = ?, expiry_date = ?, last_checked = ? WHERE machine_id = ?",
      [licenseKey, isValid ? 1 : 0, expiryDate?.toISOString(), lastChecked, machineId]
    );
  } else {
    // Insert new record
    executeQuery(
      "INSERT INTO license_validation (machine_id, license_key, is_valid, expiry_date, last_checked) VALUES (?, ?, ?, ?, ?)",
      [machineId, licenseKey, isValid ? 1 : 0, expiryDate?.toISOString(), lastChecked]
    );
  }
}

// Check if the current machine has a valid license
export function checkMachineLicense(): { valid: boolean; expiryDate?: Date; error?: string } {
  try {
    const machineId = getMachineId();
    
    // Get the license record for this machine
    const licenseRecord: any = fetchOne(
      "SELECT * FROM license_validation WHERE machine_id = ?", 
      [machineId]
    );
    
    if (!licenseRecord) {
      return { valid: false, error: 'No license found for this machine' };
    }
    
    if (!licenseRecord.is_valid) {
      return { valid: false, error: 'License is not valid' };
    }
    
    // Check expiry date if present
    if (licenseRecord.expiry_date) {
      const expiryDate = new Date(licenseRecord.expiry_date);
      if (expiryDate < new Date()) {
        // Update the record to mark as invalid
        executeQuery(
          "UPDATE license_validation SET is_valid = 0 WHERE machine_id = ?",
          [machineId]
        );
        return { valid: false, expiryDate, error: 'License has expired' };
      }
      return { valid: true, expiryDate };
    }
    
    return { valid: true };
  } catch (error) {
    console.error('Error checking machine license:', error);
    return { valid: false, error: 'Error checking license' };
  }
}